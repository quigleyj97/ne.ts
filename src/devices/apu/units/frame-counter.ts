import { u8 } from "../../../utils/types.js";

/**
 * APU Frame Counter Events
 * 
 * Events generated by the frame counter on specific sequencer steps.
 * Used for clocking various APU components.
 */
export interface FrameCounterEvents {
    /** Quarter-frame event - clocks envelopes and linear counter */
    quarterFrame: boolean;
    /** Half-frame event - clocks sweep units and length counters */
    halfFrame: boolean;
    /** IRQ event - should trigger CPU interrupt */
    irq: boolean;
}

/**
 * APU Frame Counter
 * 
 * The Frame Counter is the timing backbone of the APU that generates
 * quarter-frame and half-frame events used to clock various components.
 * 
 * It operates in two modes:
 * - **4-step mode**: Generates 4 steps over ~29830 CPU cycles, can trigger IRQ
 * - **5-step mode**: Generates 5 steps over ~37282 CPU cycles, no IRQ
 * 
 * Timing (NTSC, in CPU cycles):
 * 
 * 4-step mode:
 * | Step | Cycle | Quarter | Half | IRQ |
 * |------|-------|---------|------|-----|
 * | 1    | 7459  | Yes     | No   | No  |
 * | 2    | 14913 | Yes     | Yes  | No  |
 * | 3    | 22371 | Yes     | No   | No  |
 * | 4    | 29829 | Yes     | Yes  | Yes*|
 * 
 * 5-step mode:
 * | Step | Cycle | Quarter | Half |
 * |------|-------|---------|------|
 * | 1    | 7459  | Yes     | No   |
 * | 2    | 14913 | Yes     | Yes  |
 * | 3    | 22371 | Yes     | No   |
 * | 4    | 29829 | Yes     | Yes  |
 * | 5    | 37281 | Yes     | Yes  |
 * 
 * *IRQ only if inhibit flag is clear
 * 
 * Hardware quirks:
 * - Writing to $4017 has a 3-4 cycle delay (odd cycle = 3, even cycle = 4)
 * - After delay, sequencer resets to step 0 (no events)
 * - If switching to 5-step mode, immediately clock quarter and half after delay
 * - IRQ flag persists until read of $4015 or IRQ inhibit set
 * 
 * Based on NES APU specification:
 * https://www.nesdev.org/wiki/APU_Frame_Counter
 */
export class FrameCounter {
    //#region Sequencer Step Timing (CPU cycles)
    /** Step timing for both 4-step and 5-step modes */
    private static readonly STEP_CYCLES = [7459, 14913, 22371, 29829, 37281];
    //#endregion

    //#region Register State
    /**
     * Mode flag (bit 7 of $4017)
     * false = 4-step mode (29830 cycles)
     * true = 5-step mode (37282 cycles)
     */
    private mode: boolean = false;

    /**
     * IRQ inhibit flag (bit 6 of $4017)
     * When true, disables IRQ generation and clears IRQ flag
     */
    private irqInhibit: boolean = false;
    //#endregion

    //#region Sequencer State
    /**
     * CPU cycle when sequencer logically started
     * Used to calculate position: (current CPU cycle - base cycle) = position in sequence
     */
    private baseCycle: number = 0;

    /**
     * Current sequencer step (0-4 for 4-step, 0-5 for 5-step)
     * Step 0 is the initial state before the first step at 7459
     */
    private step: number = 0;

    /**
     * IRQ flag - set when frame IRQ should be triggered
     * Only set in 4-step mode when IRQ inhibit is clear
     */
    private irqFlag: boolean = false;
    //#endregion

    //#region Write Delay State
    /**
     * Pending write value from $4017
     * null if no write is pending
     */
    private pendingWrite: u8 | null = null;

    /**
     * CPU cycle when the pending write was issued
     * Used to set baseCycle correctly when write takes effect
     */
    private pendingWriteCycle: number = 0;

    /**
     * Countdown for write delay
     * When this reaches 0, the pending write takes effect
     */
    private writeDelay: number = 0;
    //#endregion

    /**
     * Write to Frame Counter control register ($4017)
     *
     * This implements the hardware write delay:
     * - 3 cycle delay if written on an odd CPU cycle
     * - 4 cycle delay if written on an even CPU cycle
     *
     * After the delay:
     * - Sequencer resets to step 0
     * - If 5-step mode, immediately generates quarter and half frame events
     * - If IRQ inhibit set, clears the IRQ flag
     *
     * @param value Register value containing:
     *   - Bit 7: Mode (0 = 4-step, 1 = 5-step)
     *   - Bit 6: IRQ inhibit flag
     *   - Bits 0-5: Unused
     * @param cpuCycle Current CPU cycle number (for write delay timing)
     */
    public writeControl(value: u8, cpuCycle: number): void {
        // Calculate delay: 3 cycles if odd, 4 cycles if even
        const delay = (cpuCycle % 2 === 1) ? 3 : 4;
        
        this.pendingWrite = value;
        this.pendingWriteCycle = cpuCycle;
        this.writeDelay = delay;
    }

    /**
     * Process a pending write if its delay has completed
     *
     * This is called internally by clock() to apply delayed writes.
     * Returns events object when write takes effect (to prevent cycle increment).
     *
     * @param cpuCycle Current CPU cycle number
     * @returns Events to generate, or null if no write pending/active
     */
    private processPendingWrite(cpuCycle: number): FrameCounterEvents | null {
        if (this.pendingWrite === null) {
            return null;
        }

        // Decrement delay counter
        if (this.writeDelay > 0) {
            this.writeDelay--;
            return null;
        }

        // Delay has expired, apply the write
        const value = this.pendingWrite;
        this.pendingWrite = null;

        // Apply the write
        this.mode = (value & 0x80) !== 0;
        this.irqInhibit = (value & 0x40) !== 0;

        // Clear IRQ flag if inhibit is set
        if (this.irqInhibit) {
            this.irqFlag = false;
        }

        // Reset sequencer - base becomes the cycle when write was ISSUED
        // Steps are measured relative to the original write, not when it takes effect
        this.baseCycle = this.pendingWriteCycle;
        this.step = 0;

        // If 5-step mode, immediately generate quarter and half frame events
        if (this.mode) {
            return {
                quarterFrame: true,
                halfFrame: true,
                irq: false
            };
        }

        // Return empty events for 4-step mode to signal write took effect
        return {
            quarterFrame: false,
            halfFrame: false,
            irq: false
        };
    }

    /**
     * Clock the frame counter
     *
     * This should be called once per CPU cycle. It tracks the sequencer
     * position and generates quarter-frame, half-frame, and IRQ events
     * at the appropriate times.
     *
     * @param cpuCycle Current CPU cycle number (for write delay processing)
     * @returns Events that occurred this cycle
     */
    public clock(cpuCycle: number): FrameCounterEvents {
        // Check for pending write that should take effect
        const immediateEvents = this.processPendingWrite(cpuCycle);
        if (immediateEvents !== null) {
            // Write just took effect - return the events
            return immediateEvents;
        }

        // Calculate position in sequence
        const cycleInSequence = cpuCycle - this.baseCycle;

        // Default: no events
        const events: FrameCounterEvents = {
            quarterFrame: false,
            halfFrame: false,
            irq: false
        };

        // Check if we've reached a step boundary
        const maxSteps = this.mode ? 5 : 4;
        
        // Check each step timing
        for (let i = this.step; i < maxSteps; i++) {
            if (cycleInSequence === FrameCounter.STEP_CYCLES[i]) {
                this.step = i + 1;
                
                // All steps generate quarter-frame
                events.quarterFrame = true;
                
                // Steps 2, 4 (and 5 in 5-step mode) generate half-frame
                if (i === 1 || i === 3 || i === 4) {
                    events.halfFrame = true;
                }
                
                // Step 4 in 4-step mode generates IRQ if not inhibited
                if (i === 3 && !this.mode && !this.irqInhibit) {
                    this.irqFlag = true;
                    events.irq = true;
                }
                
                break;
            }
        }

        // Check if sequence is complete and should reset
        const sequenceEnd = this.mode ? FrameCounter.STEP_CYCLES[4] : FrameCounter.STEP_CYCLES[3];
        if (cycleInSequence >= sequenceEnd) {
            // Reset to beginning of sequence
            // baseCycle is set to the cycle of the last step so next step 1 occurs at lastStep + 7459
            this.baseCycle = cpuCycle;
            this.step = 0;
        }

        // If IRQ flag is set, report it (it persists until cleared)
        if (this.irqFlag && !this.irqInhibit) {
            events.irq = true;
        }

        return events;
    }

    /**
     * Clear the IRQ flag
     * 
     * This should be called when the CPU reads the $4015 status register.
     * It clears the frame counter IRQ flag but does not affect IRQ inhibit.
     */
    public clearIrqFlag(): void {
        this.irqFlag = false;
    }

    /**
     * Check if IRQ is pending
     * 
     * @returns true if IRQ flag is set and not inhibited
     */
    public isIrqPending(): boolean {
        return this.irqFlag && !this.irqInhibit;
    }

    /**
     * Reset frame counter to power-on state
     *
     * Initializes all state to default values. This is called during
     * APU reset/power-on.
     */
    public reset(): void {
        this.mode = false;
        this.irqInhibit = false;
        this.baseCycle = 0;
        this.step = 0;
        this.irqFlag = false;
        this.pendingWrite = null;
        this.pendingWriteCycle = 0;
        this.writeDelay = 0;
    }
}
